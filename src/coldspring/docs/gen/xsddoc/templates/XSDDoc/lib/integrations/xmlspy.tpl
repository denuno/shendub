<DOCFLEX_TEMPLATE VER='1.13'>
CREATED='2009-03-31 12:23:05'
LAST_UPDATE='2009-10-30 06:36:30'
DESIGNER_TOOL='DocFlex SDK 1.x'
DESIGNER_LICENSE_TYPE='Filigris Works Team'
APP_ID='docflex-xml-xsddoc2'
APP_NAME='DocFlex/XML XSDDoc'
APP_VER='2.2.0'
APP_AUTHOR='Copyright \u00a9 2005-2009 Filigris Works,\nLeonid Rudy Softwareprodukte. All rights reserved.'
TEMPLATE_TYPE='ProcedureTemplate'
DSM_TYPE_ID='xsddoc'
ROOT_ET='#DOCUMENTS'
INIT_EXPR='spyStart (\n  getBooleanParam("integration.xmlspy.show"),\n  getStringParam ("integration.xmlspy.diagramFormat"),\n  getBooleanParam("integration.xmlspy.fixCoords")\n)'
FINISH_EXPR='spyQuit()'
<TEMPLATE_PARAMS>
	PARAM={
		param.name='integration.xmlspy.show';
		param.title='Show Application';
		param.type='boolean';
	}
	PARAM={
		param.name='integration.xmlspy.diagramFormat';
		param.title='Diagram Format';
		param.type='enum';
		param.enum.values='PNG;EMF';
	}
	PARAM={
		param.name='integration.xmlspy.fixCoords';
		param.title='Fix Imagemap Coordinates';
		param.type='boolean';
	}
	PARAM={
		param.name='xmlspy.version';
		param.title='XMLSpy Version (as integer)';
		param.type='integer';
		param.default.expr='ver = spyVersion().toInt();\n\n(ver < 2004 || ver > 2009) ? 2009 : ver';
	}
</TEMPLATE_PARAMS>
<STYLES>
	CHAR_STYLE={
		style.name='Default Paragraph Font';
		style.id='cs1';
		style.default='true';
	}
	CHAR_STYLE={
		style.name='Hyperlink';
		style.id='cs2';
		text.decor.underline='true';
		text.color.foreground='#0000FF';
	}
	PAR_STYLE={
		style.name='Normal';
		style.id='s1';
		style.default='true';
	}
</STYLES>
<ROOT>
	<ELEMENT_ITER>
		TARGET_ET='xs:schema'
		SCOPE='advanced-location-rules'
		RULES={
			'* -> #DOCUMENT[hasAttr("initial")]/xs:schema';
		}
		<BODY>
			<SS_CALL>
				SS_NAME='Process Schema'
			</SS_CALL>
		</BODY>
	</ELEMENT_ITER>
</ROOT>
<STOCK_SECTIONS>
	<FOLDER>
		MATCHING_ET='xs:schema'
		INIT_EXPR='getIntParam("xmlspy.version") <= 2007 ?\n{\n  // In xsddoc generated by XMLSpy 2007 (and erlier), the titles of components\n  // from imported schemas may start with the namespace prefixes declared in\n  // the main (importing) schema for the imported schemas\' target namespaces\n\n  nsPrefix = findPrefixByNS (\n    getAttrStringValue("targetNamespace"),\n    filterElements (\n      getPredecessorsUntilId (contextElement.id, true).toEnum(),\n      "xs:schema"\n    )\n  );\n\n  thisContext.setVar (\n    "path_prefix", \n    nsPrefix != "" ? nsPrefix + ":" : ""\n  )\n} : {\n  thisContext.setVar ("path_prefix", "")\n}'
		SS_NAME='Add Components'
		<BODY>
			<ELEMENT_ITER>
				DESCR='iterate by global attributes'
				COND='getIntParam("xmlspy.version") >= 2006\n\n// attributes are documented only since XMLSpy 2006'
				TARGET_ET='xs:attribute'
				SCOPE='simple-location-rules'
				RULES={
					'* -> xs:attribute';
				}
				SORTING='by-attr'
				SORTING_KEY={lpath='@name',ascending}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "attribute");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
				</BODY>
			</ELEMENT_ITER>
			<ELEMENT_ITER>
				DESCR='iterate by global elements'
				TARGET_ET='xs:element'
				SCOPE='simple-location-rules'
				RULES={
					'* -> xs:element';
				}
				SORTING='by-attr'
				SORTING_KEY={lpath='@name',ascending}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "element");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
					<SS_CALL>
						SS_NAME='Add Local Element & Attributes'
						PARAMS_EXPR='Array (getAttrValue("name"))'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
			<ELEMENT_ITER>
				DESCR='iterate by groups'
				TARGET_ET='xs:group'
				SCOPE='advanced-location-rules'
				RULES={
					'* -> xs:group';
					'* -> xs:redefine/xs:group';
				}
				FILTER='! hasServiceAttr ("redefined") || getIntParam("xmlspy.version") > 2006'
				SORTING='by-attr'
				SORTING_KEY={lpath='@name',ascending}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "group");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\nel.setAttr ("redef", contextElement.predecessor.instanceOf ("xs:redefine"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
					<SS_CALL>
						SS_NAME='Add Local Element & Attributes'
						PARAMS_EXPR='Array (getAttrValue("name"))'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
			<ELEMENT_ITER>
				DESCR='iterate by complex types'
				TARGET_ET='xs:complexType'
				SCOPE='advanced-location-rules'
				RULES={
					'* -> xs:complexType';
					'* -> xs:redefine/xs:complexType';
				}
				FILTER='! hasServiceAttr ("redefined") || getIntParam("xmlspy.version") > 2006'
				SORTING='by-attr'
				SORTING_KEY={lpath='@name',ascending}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "complexType");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\nel.setAttr ("redef", contextElement.predecessor.instanceOf ("xs:redefine"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
					<SS_CALL>
						SS_NAME='Add Local Element & Attributes'
						PARAMS_EXPR='Array (getAttrValue("name"))'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
			<ELEMENT_ITER>
				DESCR='iterate by attribute groups'
				TARGET_ET='xs:attributeGroup'
				SCOPE='advanced-location-rules'
				RULES={
					'* -> xs:attributeGroup';
					'* -> xs:redefine/xs:attributeGroup';
				}
				FILTER='! hasServiceAttr ("redefined") || getIntParam("xmlspy.version") > 2006'
				SORTING='by-attr'
				SORTING_KEY={lpath='@name',ascending}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "attributeGroup");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\nel.setAttr ("redef", contextElement.predecessor.instanceOf ("xs:redefine"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
					<SS_CALL>
						COND='getIntParam("xmlspy.version") >= 2008\n\n// the local attributes defined within global \n// attribute groups are not documented by \n// XMLSpy 2007 (or earlier)'
						SS_NAME='Add Local Element & Attributes'
						PARAMS_EXPR='Array (getAttrValue("name"))'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
		</BODY>
	</FOLDER>
	<FOLDER>
		MATCHING_ETS={'xs:%element';'xs:attributeGroup';'xs:complexType';'xs:group'}
		SS_NAME='Add Local Element & Attributes'
		<BODY>
			<ELEMENT_ITER>
				DESCR='iterate by local attributes defined directly within this component (not within any nested elements)'
				COND='getIntParam("xmlspy.version") >= 2006\n\n// attributes are documented only since XMLSpy 2006'
				TARGET_ET='xs:attribute%xs:attribute'
				SCOPE='advanced-location-rules'
				RULES={
					'xs:%element -> xs:complexType';
					'xs:%complexType -> xs:complexContent/(xs:extension|xs:restriction)/{baseQName = getAttrQNameValue("base");\nfindElementsByKey (\n  "types",\n  hasServiceAttr ("redefined") ? \n    HashKey (baseQName, getServiceAttr ("redefined")) : baseQName\n)}::xs:complexType',recursive;
					'xs:%complexType -> xs:simpleContent/(xs:extension|xs:restriction)/{baseQName = getAttrQNameValue("base");\nfindElementsByKey (\n  "types",\n  hasServiceAttr ("redefined") ? \n    HashKey (baseQName, getServiceAttr ("redefined")) : baseQName\n)}::xs:complexType',recursive;
					'xs:%complexType -> xs:complexContent/(xs:extension|xs:restriction)/(xs:attribute|xs:attributeGroup)',recursive;
					'xs:%complexType -> xs:simpleContent/(xs:extension|xs:restriction)/(xs:attribute|xs:attributeGroup)',recursive;
					'xs:%complexType -> (xs:attribute|xs:attributeGroup)',recursive;
					'xs:attributeGroup -> (xs:attribute|xs:attributeGroup)',recursive;
					'xs:%attributeGroupRef -> {qName = getAttrQNameValue("ref");\n\nfindElementsByKey (\n  "attributeGroups",\n  hasServiceAttr ("redefined") ?\n    HashKey (qName, getServiceAttr ("redefined")) : qName\n)}::xs:attributeGroup',recursive;
				}
				FILTER_BY_KEY='((attrQName = getAttrQNameValue("ref")) != null) ? attrQName : \nQName ({\n   schema = findAncestor ("xs:schema");\n\n   (hasAttr("form") ? getAttrValue("form") : \n                      schema.getAttrValue ("attributeFormDefault")) == "qualified"\n     ? schema.getAttrStringValue("targetNamespace") : ""\n  },\n  getAttrStringValue("name")\n)'
				FILTER_BY_KEY_COND='true'
				FILTER='hasAttr("name")\n&&\nfindPredecessorByType (\n  "xs:%element | xs:complexType | xs:attributeGroup"\n).id == iterator.contextElement.id'
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "attribute");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", stockSection.param + "/@" + getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
				</BODY>
			</ELEMENT_ITER>
			<ELEMENT_ITER>
				DESCR='iterate by local elements defined directly within this component (not within any nested elements)'
				TARGET_ET='xs:%element'
				SCOPE='advanced-location-rules'
				RULES={
					'* -> descendant::xs:%element[! hasAttr("ref") &&\n{\n  el = findPredecessorByType ("xs:%localElement");\n  el == null || el.id == stockSection.contextElement.id\n}]';
				}
				STEP_EXPR='el = CustomElement();\n\nel.setAttr ("id", contextElement.id);\nel.setAttr ("type", "element");\nel.setAttr ("name", getAttrValue("name"));\nel.setAttr ("path", stockSection.param + "/" + getAttrValue("name"));\nel.setAttr ("path_prefix", thisContext.getVar ("path_prefix"));\n\nthisContext.getVar ("components").toVector().addElement (el)'
				<BODY>
					<SS_CALL>
						SS_NAME='Add Local Element & Attributes'
						PARAMS_EXPR='Array (stockSection.param + "/" + getAttrValue("name"))'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
		</BODY>
	</FOLDER>
	<FOLDER>
		MATCHING_ET='xs:schema'
		INIT_EXPR='thisContext.setVar ("components", Vector())'
		FINISH_EXPR='spyProcessXSD (\n  getXMLDocument().getAttrStringValue("xmlURI"),\n  output.filesDir + "xmlspy/" + getXMLDocument().getAttrStringValue("xmlName").replace (".", "_"),\n  thisContext.getVar ("components").toVector()\n)'
		SS_NAME='Process Schema'
		<BODY>
			<SS_CALL>
				SS_NAME='Add Components'
			</SS_CALL>
			<ELEMENT_ITER>
				DESCR='iterate by all referenced schemas'
				TARGET_ET='xs:schema'
				SCOPE='advanced-location-rules'
				RULES={
					'* -> (xs:import|xs:include|xs:redefine)/{findElementsByKey ("loaded-schema", contextElement.id)}::xs:schema[// exclude second processing of the initial schema passed to this stock-section\n// (which may occur when it is also imported from some of those schemas imported by it)\n\ncontextElement.id != stockSection.contextElement.id]',recursive;
				}
				SORTING='by-compound-key'
				SORTING_KEY={
					{expr='getPredecessorsUntilId (iterator.contextElement, false).size()',ascending};
					{expr='el = contextElement.predecessor;\n\nel.instanceOf ("xs:include") ? 1 : \n  el.instanceOf ("xs:redefine") ? 2 : 3',ascending};
				}
				<BODY>
					<SS_CALL>
						SS_NAME='Add Components'
					</SS_CALL>
				</BODY>
			</ELEMENT_ITER>
		</BODY>
	</FOLDER>
</STOCK_SECTIONS>
CHECKSUM='BjULLF9vmMEQ94nLLlhVYz4EhgQdT3PiyZwwzuEnsus'
</DOCFLEX_TEMPLATE>